{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"@spfxappdev/storage \u00b6 @spfxappdev/storage is a library to handle the javascript localStorage and sessionStorage in a simple way. It comes with a built-in expiration logic (per default 60 minutes ). It is possible to delete the entire storage or only a specific one via URL parameters. The included decorators simplify the application and keep the code short and simple, because you only have to implement the logic (of your method) itself and not the caching (see decorators section ). Installation \u00b6 npm i @spfxappdev/storage Usage \u00b6 Depending on which type of caching you want to use ( localStorage or sessionStorage ) you must first import the class(es). But regardless of the type, the logic and handling is the same for both classes. 1. import the storage class(es) into your project \u00b6 import { LocalStorage , SessionStorage } from '@spfxappdev/storage' ; 2. You can create an instance now. \u00b6 const sessionCache = new SessionStorage (); const localCache = new LocalStorage (); 3. Set/Get Data \u00b6 Set/Get Data Example sessionCache . set ( \"mySessionStorageKey\" , \"mySessionStorageValue\" ); let dataFromCache = sessionCache . get ( \"mySessionStorageKey\" ); console . log ( dataFromCache ); //RESULT: mySessionStorageValue const myObj = { name : '@spfxappdev/storage' , install : 'npm i @spfxappdev/storage' , author : 'SPFxAppDev' }; localCache . set ( \"myLocalStorageKey\" , myObj ); console . log ( myObj ); //RESULT: (1) { name: '@spfxappdev/storage', install: 'npm i @spfxappdev/storage', author: 'SPFxAppDev' } 4. Get data or set data with callback function if not available \u00b6 let dataFromCache = localCache . get ( \"myLocalStorageKey\" , () => { //Note: (1) return { name : '@spfxappdev/storage' , install : 'npm i @spfxappdev/storage' , author : 'SPFxAppDev' }; }); If the storage key does not exist or the cache has expired, the callback function is executed. The return value of this callback function is used to store the value in the cache with the specified key . 5. Custom settings \u00b6 API \u00b6 The methods are the same regardless of the type of caching ( local or session ) you use. constructor \u00b6 constructor(customSettings?: IStorageSettings) When you create a new object instance, you can pass the optional parameter customSettings . See the usage section on how to create a new instance or the custom settings section to pass your custom settings options. set \u00b6 set(cacheKey: string, cacheValue: any, timeToLife: number = 60) This method stores the passed cacheValue with the given cacheKey in the localStorage or sessionStorage container. The timeToLife argument is optional (default = 60 minutes) and determines when the cache should expire (in minutes). If a value with the cacheKey already exists, it will be overwritten with the new cacheValue . After the value has been set, two keys exist in the respective storage. The second one has the suffix _expire which contains the timestamp as a value when the cache expires. For example, if you store a value in sessionStorage in this way: sessionCache . set ( \"mySessionStorageKey\" , \"mySessionStorageValue\" ); The storage will then looks like thit: Key Value SPFxAppDev_mySessionStorageKey mySessionStorageValue SPFxAppDev_mySessionStorageKey_expire 1674594394115 Info You can change the prefix as described in the custom settings section get \u00b6 get(cacheKey: string, delegateFunction: Function|null = null, timeToLife: number = 60) This method returns the stored value of the specified cacheKey . The cacheKey corresponds to the same value as specified in the set method . If the cacheKey does not exist, or the key with the suffix _expired does not exist, or the cache has expired AND the delegateFunction is passed, then this function is executed and the return value of this function is used to store the value in the specified cacheKey . If the delegateFunction is not passed and the cacheKey does not exist, or the key with the suffix _expired does not exist, or the cache has expired, null is returned. The timeToLife (in minutes) argument is also optional and is used if delegateFunction is passed AND the cache value is (re)set. Info Each cacheKey is stored with a KeyPrefix . If different instances exist that have different KeyPrefix values, only the value that has exactly this KeyPrefix is returned. That means if there is an instance that uses one as KeyPrefix and another that uses two as KeyPrefix , when the set method is executed with the same cacheKey (e.g. test ), two different \"storage\" keys will be created. So the keys one_test and two_test exist. The get(\"test\") method then returns only the value corresponding to the {KeyPrefixOfCurrentInstance}_{cacheKey} . => instanceWithPrefixOne.get('test') //RETURNS 'test with keyPrefix \"one\" and instanceWithPrefixTwo.get('test') //RETURNS 'test with keyPrefix \"two\" remove \u00b6 remove(cacheKey: string) Removes the cached value from storage with the specified cacheKey . The cacheKey corresponds to the same value as specified in the set method . Info Each cacheKey is stored with a KeyPrefix . If different instances exist that have different KeyPrefix values, only the value that has exactly this KeyPrefix is removed. clear \u00b6 clear() Removes any cached value from storage. But only the values that start with the KeyPrefix (=were set with this instance). exists \u00b6 exists(cacheKey: string) Checks if an item exist in storage cache with specified cacheKey . Warning this is the generell getItem -Methode of the cache store. You have to pass the KeyPrefix for the cacheKey to return the values that you stored via the set method . Or use the get method instead. getStorageKeys \u00b6 getStorageKeys() Returns all cacheKeys as string array that start with the KeyPrefix but without the _expired keys. Decorators \u00b6 The caching decorators are helpful if you want to achieve a lot with less code and also fast. They help you to program your methods with logic only, without having to take caching into care. The decorators automatically return the cached value if it exists and has not expired (without calling the logic of the method). If there is nothing in the cache or the cache has expired, the logic of the method is called and the return value is automatically written to the cache. In order to better understand how decorators work, I recommend reading this article . Note Simple definition : An ES2016 decorator is an expression which returns a function and can take a target, name and property descriptor as arguments. You apply it by prefixing the decorator with an @ character and placing this at the very top of what you are trying to decorate. Decorators can be defined for either a class, a method or a property. Let's compare the same code without decorators and with decorators. The logic is not changed, but the result is the same: Simple class WITHOUT decorators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MyExampleClass { private sesssionStorage : SessionStorage constructor () { this . sesssionStorage = new SessionStorage (); } public getDummyDataPromise () : Promise < string > { this . sesssionStorage . logger . log ( \"getDummyDataPromise START\" ); const cacheKey : string = \"getDummyDataPromise\" ; const cacheData = this . sesssionStorage . get ( cacheKey ); if ( cacheData != null ) { this . sesssionStorage . logger . log ( \"getDummyDataPromise get from cache\" ); return Promise . resolve ( cacheData ); } return new Promise (( resolve , reject ) => { setTimeout (() => { const data = \"This data is from 5s Promise\" ; this . sesssionStorage . logger . log ( \"getDummyDataPromise get from Promise\" ); this . sesssionStorage . set ( cacheKey , data ); resolve ( data ); }, 5000 ); }); } } (Same) Simple class WITH decorators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyExampleClass { @sessionCache ({ key : \"getDummyDataPromise\" }) public getDummyDataPromise () : Promise < string > { return new Promise (( resolve , reject ) => { setTimeout (() => { const data = \"This data is from 5s Promise\" ; resolve ( data ); }, 5000 ); }); } } Needless to say, decorators save a lot of time, reduce the number of lines (29 lines vs. 14 lines (~50% less)) and improve readability. How to use decorators \u00b6 To use the method decorators, you must set the experimentalDecorators property in your tsconfig.json to true . Here is a list of all available method decorators: Decorator name Description @sessionCache Return the cached value from sessionStorage (by the specified cacheKey ) or store the return value of the method if the cache has expired or is not exists @localCache Return the cached value from localStorage (by the specified cacheKey ) or store the return value of the method if the cache has expired or is not exists @clearSessionCache Removes the cached value from the sessionStorage (by the given cacheKey ) @clearLocalCache Removes the cached value from the localStorage (by the given cacheKey ) In order to use the decorators, they must be imported import decorators export { sessionCache , localCache , clearSessionCache , clearLocalCache } from '@spfxappdev/storage' ; @sessionCache \u00b6 The Options ( ISessionStorageDecoratorOptions<T> ) \u00b6 Name Type Required Description key string | ((...args: any[]) => string) Yes timeToLife number No keyPrefix string No sourceObj<T> T No convertFromCache(cachedValue: any) function No @localCache \u00b6 @clearSessionCache \u00b6 @clearLocalCache \u00b6 Clear storage via URL parameters \u00b6","title":"Home"},{"location":"#spfxappdevstorage","text":"@spfxappdev/storage is a library to handle the javascript localStorage and sessionStorage in a simple way. It comes with a built-in expiration logic (per default 60 minutes ). It is possible to delete the entire storage or only a specific one via URL parameters. The included decorators simplify the application and keep the code short and simple, because you only have to implement the logic (of your method) itself and not the caching (see decorators section ).","title":"@spfxappdev/storage"},{"location":"#installation","text":"npm i @spfxappdev/storage","title":"Installation"},{"location":"#usage","text":"Depending on which type of caching you want to use ( localStorage or sessionStorage ) you must first import the class(es). But regardless of the type, the logic and handling is the same for both classes.","title":"Usage"},{"location":"#1-import-the-storage-classes-into-your-project","text":"import { LocalStorage , SessionStorage } from '@spfxappdev/storage' ;","title":"1. import the storage class(es) into your project"},{"location":"#2-you-can-create-an-instance-now","text":"const sessionCache = new SessionStorage (); const localCache = new LocalStorage ();","title":"2. You can create an instance now."},{"location":"#3-setget-data","text":"Set/Get Data Example sessionCache . set ( \"mySessionStorageKey\" , \"mySessionStorageValue\" ); let dataFromCache = sessionCache . get ( \"mySessionStorageKey\" ); console . log ( dataFromCache ); //RESULT: mySessionStorageValue const myObj = { name : '@spfxappdev/storage' , install : 'npm i @spfxappdev/storage' , author : 'SPFxAppDev' }; localCache . set ( \"myLocalStorageKey\" , myObj ); console . log ( myObj ); //RESULT: (1) { name: '@spfxappdev/storage', install: 'npm i @spfxappdev/storage', author: 'SPFxAppDev' }","title":"3. Set/Get Data"},{"location":"#4-get-data-or-set-data-with-callback-function-if-not-available","text":"let dataFromCache = localCache . get ( \"myLocalStorageKey\" , () => { //Note: (1) return { name : '@spfxappdev/storage' , install : 'npm i @spfxappdev/storage' , author : 'SPFxAppDev' }; }); If the storage key does not exist or the cache has expired, the callback function is executed. The return value of this callback function is used to store the value in the cache with the specified key .","title":"4. Get data or set data with callback function if not available"},{"location":"#5-custom-settings","text":"","title":"5. Custom settings"},{"location":"#api","text":"The methods are the same regardless of the type of caching ( local or session ) you use.","title":"API"},{"location":"#constructor","text":"constructor(customSettings?: IStorageSettings) When you create a new object instance, you can pass the optional parameter customSettings . See the usage section on how to create a new instance or the custom settings section to pass your custom settings options.","title":"constructor"},{"location":"#set","text":"set(cacheKey: string, cacheValue: any, timeToLife: number = 60) This method stores the passed cacheValue with the given cacheKey in the localStorage or sessionStorage container. The timeToLife argument is optional (default = 60 minutes) and determines when the cache should expire (in minutes). If a value with the cacheKey already exists, it will be overwritten with the new cacheValue . After the value has been set, two keys exist in the respective storage. The second one has the suffix _expire which contains the timestamp as a value when the cache expires. For example, if you store a value in sessionStorage in this way: sessionCache . set ( \"mySessionStorageKey\" , \"mySessionStorageValue\" ); The storage will then looks like thit: Key Value SPFxAppDev_mySessionStorageKey mySessionStorageValue SPFxAppDev_mySessionStorageKey_expire 1674594394115 Info You can change the prefix as described in the custom settings section","title":"set"},{"location":"#get","text":"get(cacheKey: string, delegateFunction: Function|null = null, timeToLife: number = 60) This method returns the stored value of the specified cacheKey . The cacheKey corresponds to the same value as specified in the set method . If the cacheKey does not exist, or the key with the suffix _expired does not exist, or the cache has expired AND the delegateFunction is passed, then this function is executed and the return value of this function is used to store the value in the specified cacheKey . If the delegateFunction is not passed and the cacheKey does not exist, or the key with the suffix _expired does not exist, or the cache has expired, null is returned. The timeToLife (in minutes) argument is also optional and is used if delegateFunction is passed AND the cache value is (re)set. Info Each cacheKey is stored with a KeyPrefix . If different instances exist that have different KeyPrefix values, only the value that has exactly this KeyPrefix is returned. That means if there is an instance that uses one as KeyPrefix and another that uses two as KeyPrefix , when the set method is executed with the same cacheKey (e.g. test ), two different \"storage\" keys will be created. So the keys one_test and two_test exist. The get(\"test\") method then returns only the value corresponding to the {KeyPrefixOfCurrentInstance}_{cacheKey} . => instanceWithPrefixOne.get('test') //RETURNS 'test with keyPrefix \"one\" and instanceWithPrefixTwo.get('test') //RETURNS 'test with keyPrefix \"two\"","title":"get"},{"location":"#remove","text":"remove(cacheKey: string) Removes the cached value from storage with the specified cacheKey . The cacheKey corresponds to the same value as specified in the set method . Info Each cacheKey is stored with a KeyPrefix . If different instances exist that have different KeyPrefix values, only the value that has exactly this KeyPrefix is removed.","title":"remove"},{"location":"#clear","text":"clear() Removes any cached value from storage. But only the values that start with the KeyPrefix (=were set with this instance).","title":"clear"},{"location":"#exists","text":"exists(cacheKey: string) Checks if an item exist in storage cache with specified cacheKey . Warning this is the generell getItem -Methode of the cache store. You have to pass the KeyPrefix for the cacheKey to return the values that you stored via the set method . Or use the get method instead.","title":"exists"},{"location":"#getstoragekeys","text":"getStorageKeys() Returns all cacheKeys as string array that start with the KeyPrefix but without the _expired keys.","title":"getStorageKeys"},{"location":"#decorators","text":"The caching decorators are helpful if you want to achieve a lot with less code and also fast. They help you to program your methods with logic only, without having to take caching into care. The decorators automatically return the cached value if it exists and has not expired (without calling the logic of the method). If there is nothing in the cache or the cache has expired, the logic of the method is called and the return value is automatically written to the cache. In order to better understand how decorators work, I recommend reading this article . Note Simple definition : An ES2016 decorator is an expression which returns a function and can take a target, name and property descriptor as arguments. You apply it by prefixing the decorator with an @ character and placing this at the very top of what you are trying to decorate. Decorators can be defined for either a class, a method or a property. Let's compare the same code without decorators and with decorators. The logic is not changed, but the result is the same: Simple class WITHOUT decorators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MyExampleClass { private sesssionStorage : SessionStorage constructor () { this . sesssionStorage = new SessionStorage (); } public getDummyDataPromise () : Promise < string > { this . sesssionStorage . logger . log ( \"getDummyDataPromise START\" ); const cacheKey : string = \"getDummyDataPromise\" ; const cacheData = this . sesssionStorage . get ( cacheKey ); if ( cacheData != null ) { this . sesssionStorage . logger . log ( \"getDummyDataPromise get from cache\" ); return Promise . resolve ( cacheData ); } return new Promise (( resolve , reject ) => { setTimeout (() => { const data = \"This data is from 5s Promise\" ; this . sesssionStorage . logger . log ( \"getDummyDataPromise get from Promise\" ); this . sesssionStorage . set ( cacheKey , data ); resolve ( data ); }, 5000 ); }); } } (Same) Simple class WITH decorators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyExampleClass { @sessionCache ({ key : \"getDummyDataPromise\" }) public getDummyDataPromise () : Promise < string > { return new Promise (( resolve , reject ) => { setTimeout (() => { const data = \"This data is from 5s Promise\" ; resolve ( data ); }, 5000 ); }); } } Needless to say, decorators save a lot of time, reduce the number of lines (29 lines vs. 14 lines (~50% less)) and improve readability.","title":"Decorators"},{"location":"#how-to-use-decorators","text":"To use the method decorators, you must set the experimentalDecorators property in your tsconfig.json to true . Here is a list of all available method decorators: Decorator name Description @sessionCache Return the cached value from sessionStorage (by the specified cacheKey ) or store the return value of the method if the cache has expired or is not exists @localCache Return the cached value from localStorage (by the specified cacheKey ) or store the return value of the method if the cache has expired or is not exists @clearSessionCache Removes the cached value from the sessionStorage (by the given cacheKey ) @clearLocalCache Removes the cached value from the localStorage (by the given cacheKey ) In order to use the decorators, they must be imported import decorators export { sessionCache , localCache , clearSessionCache , clearLocalCache } from '@spfxappdev/storage' ;","title":"How to use decorators"},{"location":"#sessioncache","text":"The","title":"@sessionCache"},{"location":"#options-isessionstoragedecoratoroptionst","text":"Name Type Required Description key string | ((...args: any[]) => string) Yes timeToLife number No keyPrefix string No sourceObj<T> T No convertFromCache(cachedValue: any) function No","title":"Options (ISessionStorageDecoratorOptions&lt;T&gt;)"},{"location":"#localcache","text":"","title":"@localCache"},{"location":"#clearsessioncache","text":"","title":"@clearSessionCache"},{"location":"#clearlocalcache","text":"","title":"@clearLocalCache"},{"location":"#clear-storage-via-url-parameters","text":"","title":"Clear storage via URL parameters"}]}